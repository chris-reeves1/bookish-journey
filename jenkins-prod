pipeline {
  /******************************************************************
   * Top-level configuration (easy to teach!)                      *
   ******************************************************************/
  agent any

  /* Parametrised build */
  parameters {
    string(name: 'APP_VERSION', defaultValue: '1.0.0', description: 'Version tag to build')
    booleanParam(name: 'RUN_E2E', defaultValue: true, description: 'Run E2E (demo) stage?')
    choice(name: 'DEPLOY_ENV', choices: ['dev', 'staging', 'prod'], description: 'Deploy target')
    text(name: 'NOTES', defaultValue: 'Teaching demo run', description: 'Free-form notes')
  }

  /* Global environment (visible via env.*) */
  environment {
    APP_NAME           = 'demo-teaching-app'
    DEFAULT_TIMEOUT_M  = '5'
    CONTACT_EMAIL      = 'devops@example.com'
    // Pulling from parameters:
    VERSION            = "${params.APP_VERSION}"
    // Example of composing:
    ARTIFACT_NAME      = "${APP_NAME}-${VERSION}.tar.gz"
  }

  /* Pipeline-level behaviour and hygiene */
  options {
    buildDiscarder(logRotator(numToKeepStr: '20'))     // keep last 20 builds
    disableConcurrentBuilds()                          // one at a time
    timestamps()                                       // timestamp console
    ansiColor('xterm')                                 // nicer output
    skipDefaultCheckout(false)                         // do the normal SCM checkout
    // timeout applies to the whole pipeline if you want:
    // timeout(time: 30, unit: 'MINUTES')
  }

  /* (Optional) tools, triggers, etc.
  tools {
    // e.g., jdk 'jdk17'
  }
  triggers {
    // cron('H H * * 1-5')
  } */

  /******************************************************************
   * Stages                                                         *
   ******************************************************************/
  stages {

    stage('Prep') {
      steps {
        sh 'echo "Repo checked out at: $(pwd)"'
        sh 'ls -la'
        sh 'chmod +x scripts/*.sh || true'
      }
      post {
        success { echo 'Prep complete.' }
      }
    }

    stage('Validate Parameters (fast fail)') {
      steps {
        sh '''
          echo "APP_NAME=${APP_NAME}"
          echo "VERSION=${VERSION}"
          echo "DEPLOY_ENV=${params.DEPLOY_ENV}"
          test -n "${VERSION}" || { echo "VERSION is empty"; exit 1; }
        '''
      }
    }

    stage('Manual Gate (input)') {
      when {
        branch 'main'
      }
      options {
        timeout(time: 2, unit: 'MINUTES') // stage-level option
      }
      steps {
        input message: "Proceed with build on branch 'main'?", ok: 'Yes, continue'
        echo 'User approved the gate.'
      }
    }

    stage('Parallel Quality Checks') {
      parallel {
        stage('Lint (catchErrorâ†’UNSTABLE)') {
          steps {
            // catchError lets pipeline continue, but marks build accordingly
            catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE') {
              sh './scripts/lint.sh'
            }
          }
          post {
            unstable { echo 'Lint produced warnings (marked UNSTABLE).' }
            failure  { echo 'Lint stage failed (but pipeline continued due to catchError).' }
          }
        }

        stage('Hello Script (basic)') {
          steps {
            sh './scripts/hello.sh'
          }
        }
      }
    }

    stage('Build (timeout + retry)') {
      options {
        timeout(time: 3, unit: 'MINUTES') // stage-level timeout
        retry(2)                           // if it fails, try 2 more times
      }
      environment {
        BUILD_TMP = 'build-output'
      }
      steps {
        sh '''
          set -eux
          mkdir -p "${BUILD_TMP}"
          echo "Version: ${VERSION}" > "${BUILD_TMP}/version.txt"
          tar -czf "${ARTIFACT_NAME}" "${BUILD_TMP}"
          echo "Built artifact: ${ARTIFACT_NAME}"
        '''
      }
      post {
        success { archiveArtifacts artifacts: "${ARTIFACT_NAME}", fingerprint: true }
      }
    }

    stage('Unit Tests (warnError + test reporting)') {
      steps {
        // warnError marks the stage as unstable but does not fail the build
        warnError('Unit tests had failures (demo)') {
          sh './scripts/run_tests.sh'
        }
        // If you generate JUnit XML, you can publish it:
        // junit 'reports/*.xml'
      }
      post {
        unstable { echo 'Test issues detected (warnError made build UNSTABLE).' }
      }
    }

    stage('Demonstrate Error Handling Styles') {
      steps {
        script {
          // 1) Hard fail immediately:
          echo '1) Calling error(...) to fail fast (demo of commented-out code)'
          // error('Demonstration hard fail') // <- leave commented for teaching

          // 2) try/catch with Scripted block inside Declarative:
          try {
            sh 'bash -c "exit 0"'     // success path
            echo 'try/catch example: success'
          } catch (e) {
            echo "try/catch caught: ${e}"
          }

          // 3) catchError sets build/stage result while continuing:
          catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE') {
            sh 'bash -c "echo lint-like soft failure; exit 2"'
          }

          // 4) retry around a flaky task:
          retry(3) {
            sh './scripts/flaky_task.sh'
          }

          // 5) timeout guard:
          timeout(time: 1, unit: 'MINUTES') {
            sh 'sleep 1'
          }

          // 6) explicit unstable mark:
          // unstable('Marking build UNSTABLE for demonstration')
        }
      }
    }

    stage('Package & â€œDeployâ€ (gated + when)') {
      when {
        anyOf {
          branch 'main'
          expression { return params.DEPLOY_ENV != 'dev' } // demonstrate expression gate
        }
      }
      environment {
        DEPLOY_TARGET = "${params.DEPLOY_ENV}"
      }
      steps {
        echo "Deploying ${ARTIFACT_NAME} to ${DEPLOY_TARGET} (demo)"
        sh '''
          set -eux
          echo "Simulate deploy step..."
          echo "Artifact: ${ARTIFACT_NAME}"
          echo "Env: ${DEPLOY_TARGET}"
        '''
      }
      post {
        success { echo "Deployment (demo) complete to ${DEPLOY_TARGET}" }
      }
    }

    stage('E2E (optional, per-stage post)') {
      when { expression { return params.RUN_E2E } }
      options { timeout(time: 2, unit: 'MINUTES') }
      steps {
        sh 'echo "Running E2E... (demo)"; sleep 1'
      }
      post {
        always  { echo 'E2E always block (cleanup hooks, etc.)' }
        success { echo 'E2E success ðŸŽ‰' }
        failure { echo 'E2E failed âŒ' }
      }
    }
  } // end stages

  /******************************************************************
   * Pipeline-level post actions                                    *
   ******************************************************************/
  post {
    always {
      echo "Always: notify/log/cleanup. Contact: ${CONTACT_EMAIL}"
      // cleanWs() // if you use Workspace Cleanup plugin
    }
    success {
      echo 'Pipeline finished SUCCESS.'
    }
    unstable {
      echo 'Pipeline finished UNSTABLE (check lint/tests).'
    }
    failure {
      echo 'Pipeline FAILED.'
    }
    aborted {
      echo 'Pipeline ABORTED.'
    }
    changed {
      echo 'Result changed vs previous run.'
    }
    cleanup {
      echo 'Final cleanup hook.'
    }
  }
}
